`timescale 1ns / 1ps

//======================================================================
// Module: seg_display (数码管驱动)
// Description: 8位8段数码管动态扫描驱动模块。
//              输入一个32位的数值，每4位代表一个要在对应数码管上
//              显示的十六进制数 (0-F)。
//              输出段选(seg)和位选(an)信号。
//              严格遵循 {g,f,e,d,c,b,a} 的段选编码顺序。
//======================================================================
module seg_display(
    // --- 模块接口 ---
    input         clk,         // 输入: 100MHz 系统时钟
    input         rst_n,       // 输入: 全局复位
    input  [31:0] data,        // 输入: 要显示的8个数字 (data[3:0] 对应最右边的第0位)
    
    output reg [6:0] seg,        // 输出: 7段码 (段选)
    output reg [7:0] an          // 输出: 8位公共阳极选择 (位选)
);

    //---------------------------------------------------------
    // 1. 内部信号定义
    //---------------------------------------------------------
    
    // 扫描时钟分频器/计数器。
    // 使用18位计数器，扫描频率 = 100MHz / (2^18) ≈ 381Hz。
    // 这个频率足够快，人眼完全感觉不到闪烁。
    reg [17:0] clk_div;
    
    // 当前正在扫描的数码管位置 (0-7)。
    // 我们直接用分频计数器的高3位作为扫描指针。
    wire [2:0] scan_pos = clk_div[17:15];
    
    // 从32位输入数据中，选出的当前要显示的4位数字。
    reg [3:0] digit_to_display;

    //---------------------------------------------------------
    // 2. 扫描时钟生成
    //---------------------------------------------------------
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            clk_div <= 0;
        else
            clk_div <= clk_div + 1; // 自由运行的计数器
    end
    
    //---------------------------------------------------------
    // 3. 核心驱动逻辑 (纯组合逻辑)
    //---------------------------------------------------------
    always @(*) begin
        // --- 步骤A: 数据选择 (MUX) ---
        // 根据当前扫描的位置(scan_pos)，从32位的data总线中，选出对应的4位。
        case (scan_pos)
            3'd0: digit_to_display = data[3:0];   // 扫描最右边(第0位)的数码管
            3'd1: digit_to_display = data[7:4];   // 扫描第1位的数码管
            3'd2: digit_to_display = data[11:8];  // ...
            3'd3: digit_to_display = data[15:12];
            3'd4: digit_to_display = data[19:16];
            3'd5: digit_to_display = data[23:20];
            3'd6: digit_to_display = data[27:24];
            3'd7: digit_to_display = data[31:28]; // 扫描最左边(第7位)的数码管
            default: digit_to_display = 4'hF;     // 理论上不会发生，默认显示F (熄灭)
        endcase

        // --- 步骤B: 位选译码 ---
        // 根据当前扫描的位置(scan_pos)，生成位选信号 an (低电平有效)。
        // 这确保了在任何一个瞬间，只有一根an线是低电平，即只有一个数码管被激活。
        case (scan_pos)
            3'd0: an = 8'b11111110; // 激活最右边(第0位)的数码管
            3'd1: an = 8'b11111101; // 激活第1位的数码管
            3'd2: an = 8'b11111011; // ...
            3'd3: an = 8'b11110111;
            3'd4: an = 8'b11101111;
            3'd5: an = 8'b11011111;
            3'd6: an = 8'b10111111;
            3'd7: an = 8'b01111111; // 激活最左边(第7位)的数码管
            default: an = 8'b11111111; // 默认全不激活
        endcase
        
        // --- 步骤C: 段选译码 (4位转7位) ---
        // 将选出的4位数字(digit_to_display)，翻译成对应的7段码。
        // 【【【严格遵循 7'b{g, f, e, d, c, b, a} 格式，0亮1纭俊俊
        case (digit_to_display)
            4'd0: seg = 7'b1000000;
            4'd1: seg = 7'b1111001;
            4'd2: seg = 7'b0100100;
            4'd3: seg = 7'b0110000;
            4'd4: seg = 7'b0011001;
            4'd5: seg = 7'b0010010;
            4'd6: seg = 7'b0000010;
            4'd7: seg = 7'b1111000;
            4'd8: seg = 7'b0000000;
            4'd9: seg = 7'b0010000;
            4'ha: seg = 7'b0001000; // A
            4'hb: seg = 7'b0000011; // b
            4'hc: seg = 7'b1000110; // C
            4'hd: seg = 7'b0100001; // d
            4'he: seg = 7'b0000110; // E
            4'hf: seg = 7'b0001110; // F
            default: seg = 7'b1111111; // 其他情况(比如无效输入)，全灭
        endcase
    end
endmodule